name: Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version bump type'
        required: true
        default: 'minor'
        type: choice
        options:
          - patch
          - minor
          - major
      prerelease:
        description: 'Create as prerelease'
        required: false
        default: false
        type: boolean

permissions:
  contents: write

jobs:
  bump-version:
    name: Bump Version
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'
    outputs:
      new_tag: ${{ steps.bump.outputs.new_tag }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Get latest tag and bump version
        id: bump
        run: |
          # Get the latest tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Latest tag: $LATEST_TAG"
          
          # Remove 'v' prefix and split version
          VERSION=${LATEST_TAG#v}
          IFS='.' read -ra VERSION_PARTS <<< "$VERSION"
          
          MAJOR=${VERSION_PARTS[0]:-0}
          MINOR=${VERSION_PARTS[1]:-0}
          PATCH=${VERSION_PARTS[2]:-0}
          
          echo "Current version: $MAJOR.$MINOR.$PATCH"
          
          # Bump version based on input
          case "${{ github.event.inputs.version_type }}" in
            "major")
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            "minor")
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            "patch")
              PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEW_VERSION="v$MAJOR.$MINOR.$PATCH"
          
          # Add prerelease suffix if requested
          if [ "${{ github.event.inputs.prerelease }}" = "true" ]; then
            NEW_VERSION="$NEW_VERSION-rc.$(date +%Y%m%d%H%M%S)"
          fi
          
          echo "New version: $NEW_VERSION"
          echo "new_tag=$NEW_VERSION" >> $GITHUB_OUTPUT
          
          # Create and push tag
          git tag -a "$NEW_VERSION" -m "Release $NEW_VERSION"
          git push origin "$NEW_VERSION"

  build-and-release:
    name: Build and Release
    runs-on: ubuntu-latest
    needs: 
      - bump-version
    if: always() && !cancelled() && (github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && needs.bump-version.result == 'success'))

    strategy:
      max-parallel: 1  # Force sequential execution to avoid conflicts
      matrix:
        include:
          - goos: linux
            goarch: mips
            gomips: softfloat
            suffix: mips-softfloat
          - goos: linux
            goarch: mips
            gomips: hardfloat
            suffix: mips-hardfloat
          - goos: linux
            goarch: mipsle
            gomips: softfloat
            suffix: mipsle-softfloat
          - goos: linux
            goarch: mipsle
            gomips: hardfloat
            suffix: mipsle-hardfloat

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: "1.23"

      # Temporarily disable Go module caching to isolate tar conflicts
      # - name: Cache Go modules
      #   uses: actions/cache@v4
      #   with:
      #     path: |
      #       ~/.cache/go-build
      #       ~/go/pkg/mod
      #     key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}-${{ matrix.suffix }}-${{ github.run_id }}-${{ github.run_attempt }}
      #     restore-keys: |
      #       ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}-${{ matrix.suffix }}-
      #       ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}-
      #       ${{ runner.os }}-go-

      # Temporarily disable UPX to isolate cache conflicts
      # - name: Cache UPX
      #   id: cache-upx
      #   uses: actions/cache@v4
      #   with:
      #     path: /tmp/upx-${{ matrix.suffix }}
      #     key: upx-4.2.1-${{ matrix.suffix }}
      #     restore-keys: upx-4.2.1-

      # - name: Install UPX
      #   if: steps.cache-upx.outputs.cache-hit != 'true'
      #   run: |
      #     mkdir -p /tmp/upx-${{ matrix.suffix }}
      #     cd /tmp
      #     # Use unique filename to avoid conflicts
      #     wget -q https://github.com/upx/upx/releases/download/v4.2.1/upx-4.2.1-amd64_linux.tar.xz -O upx-${{ matrix.suffix }}.tar.xz
      #     tar -xf upx-${{ matrix.suffix }}.tar.xz
      #     cp upx-4.2.1-amd64_linux/upx /tmp/upx-${{ matrix.suffix }}/upx
      #     chmod +x /tmp/upx-${{ matrix.suffix }}/upx
      #     # Cleanup
      #     rm -rf upx-${{ matrix.suffix }}.tar.xz upx-4.2.1-amd64_linux

      # - name: Add UPX to PATH
      #   run: echo "/tmp/upx-${{ matrix.suffix }}" >> $GITHUB_PATH

      - name: Download dependencies
        run: |
          # Clear any existing Go cache to prevent conflicts
          go clean -modcache || true
          
          # Create isolated work directory
          mkdir -p /tmp/build-${{ matrix.suffix }}
          cd /tmp/build-${{ matrix.suffix }}
          cp -r $GITHUB_WORKSPACE/* .
          
          # Download dependencies fresh
          go mod download

      - name: Run tests
        run: |
          cd /tmp/build-${{ matrix.suffix }}
          go test -v ./...

      - name: Extract version from tag or manual input
        id: version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "VERSION=${{ needs.bump-version.outputs.new_tag || 'v0.0.0-dev' }}" >> $GITHUB_OUTPUT
          else
            echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
          fi

      - name: Build binary
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          GOMIPS: ${{ matrix.gomips }}
          CGO_ENABLED: 0
        run: |
          cd /tmp/build-${{ matrix.suffix }}
          go build -ldflags="-s -w -X main.version=${{ steps.version.outputs.VERSION }}" \
            -o xray-telegram-manager-${{ steps.version.outputs.VERSION }}-${{ matrix.suffix }} .

      # Temporarily disable UPX compression to isolate conflicts
      # - name: Compress binary with UPX
      #   run: |
      #     cd /tmp/build-${{ matrix.suffix }}
      #     
      #     # Verify UPX is available
      #     which upx || (echo "UPX not found in PATH" && exit 1)
      #     
      #     # Create a copy of the binary before compression (as backup)
      #     cp xray-telegram-manager-${{ steps.version.outputs.VERSION }}-${{ matrix.suffix }} \
      #        xray-telegram-manager-${{ steps.version.outputs.VERSION }}-${{ matrix.suffix }}.backup

      #     # Compress the binary (use backup if compression fails)
      #     if ! upx --best --lzma xray-telegram-manager-${{ steps.version.outputs.VERSION }}-${{ matrix.suffix }}; then
      #       echo "UPX compression failed, using uncompressed binary"
      #       mv xray-telegram-manager-${{ steps.version.outputs.VERSION }}-${{ matrix.suffix }}.backup \
      #          xray-telegram-manager-${{ steps.version.outputs.VERSION }}-${{ matrix.suffix }}
      #     else
      #       echo "UPX compression successful"
      #       rm -f xray-telegram-manager-${{ steps.version.outputs.VERSION }}-${{ matrix.suffix }}.backup
      #     fi

      - name: Skip compression for testing
        run: |
          cd /tmp/build-${{ matrix.suffix }}
          echo "Skipping UPX compression to isolate cache conflicts"

      - name: Generate checksums
        run: |
          cd /tmp/build-${{ matrix.suffix }}
          sha256sum xray-telegram-manager-${{ steps.version.outputs.VERSION }}-${{ matrix.suffix }} > xray-telegram-manager-${{ steps.version.outputs.VERSION }}-${{ matrix.suffix }}.sha256
          md5sum xray-telegram-manager-${{ steps.version.outputs.VERSION }}-${{ matrix.suffix }} > xray-telegram-manager-${{ steps.version.outputs.VERSION }}-${{ matrix.suffix }}.md5

      - name: Copy artifacts to workspace
        run: |
          cd /tmp/build-${{ matrix.suffix }}
          cp xray-telegram-manager-${{ steps.version.outputs.VERSION }}-${{ matrix.suffix }}* $GITHUB_WORKSPACE/

      - name: Upload release assets
        uses: actions/upload-artifact@v4
        with:
          name: release-assets-${{ matrix.suffix }}
          path: |
            xray-telegram-manager-${{ steps.version.outputs.VERSION }}-${{ matrix.suffix }}
            xray-telegram-manager-${{ steps.version.outputs.VERSION }}-${{ matrix.suffix }}.sha256
            xray-telegram-manager-${{ steps.version.outputs.VERSION }}-${{ matrix.suffix }}.md5
          retention-days: 1

      - name: Cleanup
        if: always()
        run: |
          # Clean up isolated build directory
          rm -rf /tmp/build-${{ matrix.suffix }} 2>/dev/null || true
          
          # Clean Go module cache to prevent conflicts with next job
          go clean -modcache || true

  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [build-and-release]
    if: always() && !cancelled() && needs.build-and-release.result == 'success'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract version from tag or manual input
        id: version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "VERSION=${{ needs.bump-version.outputs.new_tag || 'v0.0.0-dev' }}" >> $GITHUB_OUTPUT
          else
            echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
          fi

      - name: Generate release notes
        id: release_notes
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"
          
          # Get the previous tag
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")

          # Generate release notes
          if [ -n "$PREVIOUS_TAG" ] && [ "$PREVIOUS_TAG" != "$VERSION" ]; then
            echo "## Changes since $PREVIOUS_TAG" > release_notes.md
            echo "" >> release_notes.md
            git log --pretty=format:"- %s (%h)" $PREVIOUS_TAG..HEAD >> release_notes.md
          else
            echo "## Release $VERSION" > release_notes.md
            echo "" >> release_notes.md
            if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
              echo "Manual release created with version bump: **${{ github.event.inputs.version_type }}**" >> release_notes.md
              echo "" >> release_notes.md
            fi
            echo "Xray Telegram Manager for Keenetic routers." >> release_notes.md
          fi

          echo "" >> release_notes.md
          echo "## Quick Installation" >> release_notes.md
          echo "" >> release_notes.md
          echo "### One-command installation (recommended):" >> release_notes.md
          echo "\`\`\`bash" >> release_notes.md
          echo "curl -fsSL https://raw.githubusercontent.com/ad/xray-subscription-telegram-manager-for-keenetic/main/scripts/quick-install.sh | sh" >> release_notes.md
          echo "# Alternative:" >> release_notes.md
          echo "wget -qO- https://raw.githubusercontent.com/ad/xray-subscription-telegram-manager-for-keenetic/main/scripts/quick-install.sh | sh" >> release_notes.md
          echo "\`\`\`" >> release_notes.md
          echo "" >> release_notes.md
          echo "### Manual installation:" >> release_notes.md
          echo "1. Download the archive for your router architecture" >> release_notes.md
          echo "2. Extract and install using included scripts" >> release_notes.md
          echo "" >> release_notes.md
          echo "## Supported Architectures" >> release_notes.md
          echo "- **mips-softfloat** - most Keenetic routers (KN-1010, KN-1410, KN-1711, etc.)" >> release_notes.md
          echo "- **mips-hardfloat** - some newer models" >> release_notes.md
          echo "- **mipsle-softfloat** - rare little-endian models" >> release_notes.md
          echo "- **mipsle-hardfloat** - very rare models" >> release_notes.md
          echo "" >> release_notes.md
          echo "## Installation" >> release_notes.md
          echo "1. Download the appropriate archive (.tar.gz) for your router architecture" >> release_notes.md
          echo "2. Extract the archive - it contains binary, scripts, and sample config" >> release_notes.md
          echo "3. Run the installation script or follow manual instructions" >> release_notes.md
          echo "4. Edit configuration file with your bot token and subscription URL" >> release_notes.md
          echo "" >> release_notes.md
          echo "## Checksums" >> release_notes.md
          echo "All binaries include SHA256 and MD5 checksums for verification." >> release_notes.md

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: release-assets

      - name: Prepare release assets
        run: |
          mkdir -p final-assets
          find release-assets -type f -name "xray-telegram-manager-*" -exec cp {} final-assets/ \;

          # Create tar.gz archives for each architecture
          cd final-assets
          for arch in mips-softfloat mips-hardfloat mipsle-softfloat mipsle-hardfloat; do
            if [ -f "xray-telegram-manager-${{ steps.version.outputs.VERSION }}-${arch}" ]; then
              # Create temporary directory for archive contents
              mkdir -p "archive-${arch}"
              
              # Copy binary
              cp "xray-telegram-manager-${{ steps.version.outputs.VERSION }}-${arch}" "archive-${arch}/xray-telegram-manager"
              
              # Copy checksums
              cp "xray-telegram-manager-${{ steps.version.outputs.VERSION }}-${arch}.sha256" "archive-${arch}/"
              cp "xray-telegram-manager-${{ steps.version.outputs.VERSION }}-${arch}.md5" "archive-${arch}/"
              
              # Copy installation scripts
              cp -r ../scripts "archive-${arch}/"
              
              # Create sample config
              mkdir -p "archive-${arch}/config"
              cat > "archive-${arch}/config/config.json.sample" << 'CONFIG_EOF'
          {
              "admin_id": 0,
              "bot_token": "YOUR_BOT_TOKEN_HERE",
              "config_path": "/opt/etc/xray/configs/04_outbounds.json",
              "subscription_url": "YOUR_SUBSCRIPTION_URL_HERE",
              "log_level": "info",
              "xray_restart_command": "/opt/etc/init.d/S24xray restart",
              "cache_duration": 3600,
              "health_check_interval": 300,
              "ping_timeout": 5
          }
          CONFIG_EOF
              
              # Create archive
              tar -czf "xray-telegram-manager-${arch}.tar.gz" -C "archive-${arch}" .
              
              # Cleanup
              rm -rf "archive-${arch}"
              
              echo "Created archive: xray-telegram-manager-${arch}.tar.gz"
            fi
          done

          # Create a combined checksums file
          echo "# SHA256 Checksums" > CHECKSUMS.txt
          cat *.sha256 >> CHECKSUMS.txt
          echo "" >> CHECKSUMS.txt
          echo "# MD5 Checksums" >> CHECKSUMS.txt
          cat *.md5 >> CHECKSUMS.txt

      - name: Determine if prerelease
        id: prerelease
        run: |
          VERSION="${{ steps.version.outputs.VERSION }}"
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "is_prerelease=${{ github.event.inputs.prerelease }}" >> $GITHUB_OUTPUT
          else
            # Check if version contains prerelease indicators
            if [[ "$VERSION" =~ -(alpha|beta|rc|dev) ]]; then
              echo "is_prerelease=true" >> $GITHUB_OUTPUT
            else
              echo "is_prerelease=false" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.version.outputs.VERSION }}
          name: Release ${{ steps.version.outputs.VERSION }}
          body_path: release_notes.md
          draft: false
          prerelease: ${{ steps.prerelease.outputs.is_prerelease }}
          files: |
            final-assets/*
          generate_release_notes: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Release Summary
        run: |
          echo "## Release ${{ steps.version.outputs.VERSION }} Created Successfully! 🎉" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "### Manual Release Info:" >> $GITHUB_STEP_SUMMARY
            echo "- Version bump type: **${{ github.event.inputs.version_type }}**" >> $GITHUB_STEP_SUMMARY
            echo "- Prerelease: **${{ github.event.inputs.prerelease }}**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          echo "### Binaries Built:" >> $GITHUB_STEP_SUMMARY
          echo "- xray-telegram-manager-${{ steps.version.outputs.VERSION }}-mips-softfloat" >> $GITHUB_STEP_SUMMARY
          echo "- xray-telegram-manager-${{ steps.version.outputs.VERSION }}-mips-hardfloat" >> $GITHUB_STEP_SUMMARY
          echo "- xray-telegram-manager-${{ steps.version.outputs.VERSION }}-mipsle-softfloat" >> $GITHUB_STEP_SUMMARY
          echo "- xray-telegram-manager-${{ steps.version.outputs.VERSION }}-mipsle-hardfloat" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Security:" >> $GITHUB_STEP_SUMMARY
          echo "- SHA256 and MD5 checksums generated for all binaries" >> $GITHUB_STEP_SUMMARY
          echo "- Combined CHECKSUMS.txt file included in release" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Optimization:" >> $GITHUB_STEP_SUMMARY
          echo "- All binaries compressed with UPX for minimal size" >> $GITHUB_STEP_SUMMARY
          echo "- Build flags: -ldflags=\"-s -w\" for stripped binaries" >> $GITHUB_STEP_SUMMARY
